话说。。。经过上星期[【面试官来袭】第三弹之MySQL原理篇](https://mp.weixin.qq.com/s/BRn4wXS8afzKjwjkkZ6ATg)的洗礼，大家是不是还有些没缓过神来？

今天就来分享一道轻松有趣的算法题，缓解一下面试的紧张氛围吧～

## 故事起源

这天，纽特打开行李箱，发现我们的小财迷嗅嗅又不见了，原来，嗅嗅发现了一个每间房子都装满金光闪闪金币的社区，这可是嗅嗅梦寐以求的天堂，立马趁纽特不注意，准备打家劫舍去了。
<center>
  
![](https://mmbiz.qpic.cn/mmbiz_gif/HQKXnkPzzdtBiao6KJvufMCTWesXzu4kqbibgu3ibwhqK4aQJjyfnUxbM5GOxv6rv2ZDBX8bf4Fkh35CmxpNOsVIw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)</center>

每间房子都藏有一定的金币，影响嗅嗅吸金的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间<b><font color=blue>相邻的房屋</b></font>在同一晚上被闯入，系统会自动报警。

我们给定一个代表每个房屋存放金额的非负整数数组，计算嗅嗅不触动警报装置的情况下 ，一夜之内能够偷窃到的最多金币。

🌰：

输入
[3,2,1,2]

<center>

![](https://files.mdnice.com/user/13621/8d50582d-1c87-4e36-b8cb-42c112abdb05.png)</center>

## 条件分析

两间<b><font color=blue>相邻的房屋</b></font>在同一晚上被嗅嗅闯入就会触发警报，那么两间屋子里的金币可以说<b><font color=blue>是互斥的</b></font>，嗅嗅不能同时获取，要有取舍。
<center>

![](https://files.mdnice.com/user/13621/fa637cf7-d0b5-4f14-884d-e84a05055473.png)</center>

那是不是说嗅嗅只要间隔获取就行了？
<center>

![](https://files.mdnice.com/user/13621/0741741c-85a6-4e93-8f34-2476ea0ec501.png)</center>

如图所示，间隔获取的情况下，嗅嗅可以拿0号房和2号房的金币，也就是4个金币；还可以选择拿1号房和3号房的金币，也是4个金币，那么最优解就是4块钱了么？当然不是的，我们可以很明显地看出反例：
<center>

![](https://files.mdnice.com/user/13621/75b5b783-e1ab-4682-ab0e-d51179c2f7e6.png)</center>

如果嗅嗅拿0号房子、3号房的钱，那么可以得到5块钱，这才是最优解！

输入
[3,2,1,2]

输出
5

根据上面的分析，我们可以看出，房子之间的间隔，是没有规律的，完全可以隔很多间，我们不能通过规律的间隔来解决。

那么可以通过状态解决吗？

## 子问题推大问题

我们目标是4间房子的最优解，那么偷前三间的最优解，和我们的目标，会有联系么？

仔细想想，应该是有的。我们用<b><font color=blue>dp[i]</b></font>来表示考虑前i+1间房子的最优解，<b><font color=blue>nums[i]</b></font>表示房子的序号，让我们来分析下。
<center>

![](https://files.mdnice.com/user/13621/333e3930-b4b4-4c2e-9983-5d16126ca2c8.png)</center>

正常来说，<b><font color=blue>dp[3]的值</b></font>，应该是<b><font color=blue>由dp[2]的值</b></font>，<b><font color=blue>加上nums[3]决定</b></font>，但是我们题目中有个关键信息——相邻两间房子互斥。

那么这里就要分两种情况：

第一种，dp[2]的值，里面是包含了nums[2]的，这种情况下，dp[3]应该是dp[1]加上nums[2]或者dp[2]，取两者最大值，这样能避免冲突；

第二种，dp[2]的值中，不包含nums[2]，那么很简单，dp[3]就是dp[2]加上nums[3]。
<center>

![](https://mmbiz.qpic.cn/mmbiz_gif/HQKXnkPzzdtBiao6KJvufMCTWesXzu4kqYOarxZKPUtM1kGVdLppeBLBQyc5ZrmoNRPPgBIyte3saza3OicNUlIg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)</center>

现在就剩一个问题，dp[2]表示偷前三间房的最大值，单个值并不能表达出它是否包含num[2]，那该怎么办呢？
<center>

![](https://files.mdnice.com/user/13621/8314281b-208c-4704-89c2-6beda088710e.png)</center>

dp[2]不包含nums[2]的情况下，dp[2]就应该等于dp[1]，所以，我们就可以用这个关系，反过来判断是否dp[2]包含nums[2]。

## 代码实现

我们总结下刚才的分析，能得到这么个结论：

<b><font color=blue>dp[i]完全可以通过由dp[i-1]或者dp[i-2]推算得出</b></font>。这里牛牛也给个代码参考：
<center>

![](https://files.mdnice.com/user/13621/e0481cb9-2b47-4069-b46e-4cf96dc159de.png)</center>

## 嗅嗅复盘

这种算一定范围的最优解，通常可以考虑状态递推，也就是<b><font color=blue>动态规划</b></font>。从上一个状态，看能不能推导出下一个状态。


最后，附上如何活捉一只可爱的嗅嗅～
<center>
  
![](https://mmbiz.qpic.cn/mmbiz_gif/HQKXnkPzzduF0JFyHEaMUOiazpjqnhNICNW8hXeFhGicxy44glm0Fjx5ZRG6JuWQ45jZqGgKxlkicwBYQyEccp8eQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)</center>